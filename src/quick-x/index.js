class ShaUtils {
  static hmacSha256 = CryptoJS.HmacSHA256;
  static sha256 = CryptoJS.SHA256;
}

function getRTP() {
  const urlParams = new URLSearchParams(window.location.search);
  const rtpParam = urlParams.get('rtp');
  return rtpParam ? parseInt(rtpParam, 10) : 97;
}

class RoundSettler {
  static N_BITS = 52;
  static DIVIDER = Math.pow(2, this.N_BITS);
  static RANGE_LENGTH = Math.floor(this.N_BITS / 4); // 13 hex characters
  static NORMALIZED_X_MAX = 0.9999;

  static SCALE_SEARCH_LOW = 1e-12;
  static SCALE_SEARCH_INITIAL_HIGH = 1e6;
  static SCALE_SEARCH_MAX_HIGH = 1e12;
  static SCALE_SEARCH_PRECISION_STEPS = 50;

  static RISK_PROFILES = {
    LOW: {
      splitThreshold: 0.75,
      lowPartMin: 0.2,
      lowPartMax: 1.8,
      lowPartPower: 0.6,
      maxMultiplier: 50.0
    },
    MEDIUM: {
      splitThreshold: 0.50,
      lowPartMin: 0.1,
      lowPartMax: 2.0,
      lowPartPower: 0.65,
      maxMultiplier: 100.0
    },
    HIGH: {
      splitThreshold: 0.30,
      lowPartMin: 0.05,
      lowPartMax: 2.5,
      lowPartPower: 0.9,
      maxMultiplier: 200.0
    }
  };

  // Precomputed parameters for current RTP and Risk Level
  static rtpToParams = null;

  /**
   * Computes the expected (average) multiplier for a given scale and risk.
   *
   * The multiplier is generated by transformation: y = scale * x / (1 - x) where x ~ Uniform[0, 1).
   * This creates a distribution with probability density function: f(y) = scale / (scale + y)^2.
   *
   * The expected value is: E[Y] = ∫[0..maxMultiplier] y * f(y) dy
   * Solving this integral gives: E[Y] = scale * ln(1 + maxMultiplier / scale)
   *
   * (Note: This is an approximation that works well when maxMultiplier >> scale)
   */
  static expectedMean(scale, risk) {
    const maxMultiplier = this.RISK_PROFILES[risk].maxMultiplier;
    return scale * Math.log(1.0 + maxMultiplier / scale);
  }

  /**
   * Finds the scale parameter using binary search
   */
  static computeScaleForMean(requiredMean, risk) {
    if (requiredMean <= 0) return this.SCALE_SEARCH_LOW;

    let low = this.SCALE_SEARCH_LOW;
    let high = this.SCALE_SEARCH_INITIAL_HIGH;

    while (this.expectedMean(high, risk) < requiredMean) {
      high *= 2;
      if (high > this.SCALE_SEARCH_MAX_HIGH) break;
    }

    for (let i = 0; i < this.SCALE_SEARCH_PRECISION_STEPS; i++) {
      const mid = (low + high) / 2;
      const expectedMean = this.expectedMean(mid, risk);

      if (expectedMean < requiredMean) {
        low = mid;
      } else {
        high = mid;
      }
    }

    return (low + high) / 2;
  }

  /**
   * Computes hybrid model parameters for given RTP and risk.
   * Balance equation: P(low) * E[low] + P(high) * E[high] = convertedRtp
   */
  static computeHybridParams(convertedRtp, risk) {
    const profile = this.RISK_PROFILES[risk];

    const lowPartMean = profile.lowPartMin +
      (profile.lowPartMax - profile.lowPartMin) / (profile.lowPartPower + 1.0);

    const requiredHighPartMean =
      (convertedRtp - profile.splitThreshold * lowPartMean) /
      (1.0 - profile.splitThreshold);

    const highPartScale = this.computeScaleForMean(requiredHighPartMean, risk);

    return {
      profile: profile,
      lowPartMean: lowPartMean,
      highPartScale: highPartScale
    };
  }

  /**
   * Rounds a number to 2 decimal places using HALF_UP rounding
   */
  static round(x) {
    // Multiply by 100, add 0.5 for HALF_UP rounding, floor, then divide by 100
    return Math.floor(x * 100 + 0.5) / 100;
  }

  /**
   * Initializes precomputed parameters (called once)
   */
  static initializeParams() {
    if (this.rtpToParams !== null) return;

    const rtp = getRTP();
    const params = {};
    params[rtp] = {};
    const convertedRtp = rtp / 100.0;
    Object.keys(this.RISK_PROFILES).forEach(risk => {
      params[rtp][risk] = this.computeHybridParams(convertedRtp, risk);
    });
    this.rtpToParams = params;
  }

  /**
   * Computes multiplier from hash using the hybrid distribution algorithm
   */
  static compute(hash, rtp, risk) {
    this.initializeParams();
    const params = this.rtpToParams[rtp][risk];
    const profile = params.profile;

    // Take first RANGE_LENGTH hex characters (13 characters for 52 bits)
    const hashPart = hash.slice(0, this.RANGE_LENGTH);
    const r = parseInt(hashPart, 16);

    // Convert to normalized value [0, 1)
    const x = parseFloat((r / this.DIVIDER).toPrecision(9));

    let multiplier;
    if (x < profile.splitThreshold) {
      // Low part distribution: f(u) = a + (b-a) * u^p, where u ∈ [0,1)
      const normalizedX = x / profile.splitThreshold;
      multiplier = profile.lowPartMin +
        (profile.lowPartMax - profile.lowPartMin) *
        Math.pow(normalizedX, profile.lowPartPower);
    } else {
      // High part distribution (heavy-tailed)
      const normalizedX = (x - profile.splitThreshold) / (1.0 - profile.splitThreshold);

      if (normalizedX >= this.NORMALIZED_X_MAX) {
        multiplier = profile.maxMultiplier;
      } else {
        const raw = params.highPartScale * normalizedX / (1.0 - normalizedX);
        multiplier = Math.min(profile.maxMultiplier, raw);
      }
    }

    return this.round(multiplier);
  }

  static getData(serverSeed, nonce, clientSeed, rtp, risk = 'MEDIUM') {
    const message = `${clientSeed}:${nonce}`;
    const hash = ShaUtils.hmacSha256(message, serverSeed).toString();

    const multiplier = this.compute(hash, rtp, risk);

    return {
      sha256: ShaUtils.sha256(serverSeed).toString(),
      hash,
      multiplier,
      rtp,
      risk
    };
  }
}

let appState = {
  serverSeed: '',
  nonce: '',
  clientSeed: '',
  risk: 'MEDIUM',
  sha256: '',
  multiplier: null,
  hash: ''
};

function updateResults() {
  if (!appState.serverSeed || !appState.nonce || !appState.clientSeed) {
    appState.sha256 = '';
    appState.hash = '';
    appState.multiplier = null;
    renderResults();
    return;
  }

  try {
    const rtp = getRTP();
    const data = RoundSettler.getData(appState.serverSeed, appState.nonce, appState.clientSeed, rtp, appState.risk);
    appState.sha256 = data.sha256;
    appState.hash = data.hash;
    appState.multiplier = data.multiplier;
  } catch (error) {
    console.error('Error calculating results:', error);
    appState.sha256 = '';
    appState.hash = '';
    appState.multiplier = null;
  }

  renderResults();
}

function createResultRow(multiplier, hashPart) {
  const resultWrapper = document.createElement('div');
  resultWrapper.className = 'result-wrapper';

  const multiplierDiv = document.createElement('div');
  multiplierDiv.className = 'multiplier';
  multiplierDiv.textContent = `${multiplier.toFixed(2)}x`;

  const hashPartDiv = document.createElement('div');
  hashPartDiv.className = 'hash-part';
  hashPartDiv.textContent = hashPart;

  resultWrapper.appendChild(multiplierDiv);
  resultWrapper.appendChild(hashPartDiv);

  return resultWrapper;
}

function renderResults() {
  const sha256Input = document.getElementById('sha256-input');
  if (sha256Input) {
    sha256Input.value = appState.sha256;
  }

  const resultsContainer = document.getElementById('results-container');

  if (appState.multiplier === null) {
    resultsContainer.style.display = 'none';
    return;
  }

  resultsContainer.style.display = 'flex';
  const resultsWrapper = document.getElementById('results-wrapper');

  resultsWrapper.innerHTML = '';

  const helperText = document.createElement('div');
  helperText.className = 'helper-text';

  const step = document.createElement('div');
  step.className = 'step';
  step.innerHTML = `
    <h4>Multiplier is calculated following these steps:</h4>
    <div><b>Step 1:</b> Calculate <strong>HMAC-SHA256</strong> of message "clientSeed:nonce" with key serverSeed</div>
    <div><b>Step 2:</b> Take first <strong>${RoundSettler.RANGE_LENGTH} hex characters</strong> from the hash (represents 52 bits)</div>
    <div><b>Step 3:</b> Convert hex to decimal number <strong>r</strong></div>
    <div><b>Step 4:</b> Normalize: <strong>x = r / 2^52</strong> (value in range [0, 1))</div>
    <div><b>Step 5:</b> Apply hybrid distribution algorithm based on <strong>RTP=${getRTP()}%</strong> and <strong>Risk=${appState.risk}</strong></div>
    <div><b>Step 6:</b> Round result to <strong>2 decimal places</strong></div>
  `;

  helperText.appendChild(step);

  resultsWrapper.appendChild(helperText);

  const hashPart = appState.hash;
  const resultRow = createResultRow(appState.multiplier, hashPart);
  resultsWrapper.appendChild(resultRow);
}

function handleServerSeedChange(event) {
  appState.serverSeed = event.target.value;
  updateResults();
}

function handleNonceChange(event) {
  appState.nonce = event.target.value;
  updateResults();
}

function handleClientSeedChange(event) {
  appState.clientSeed = event.target.value;
  updateResults();
}

function handleRiskChange(event) {
  appState.risk = event.target.value;
  updateResults();
}

function initApp() {
  const serverSeedInput = document.getElementById('server-seed-input');
  const nonceInput = document.getElementById('nonce-input');
  const clientSeedInput = document.getElementById('client-seed-input');
  const riskInput = document.getElementById('risk-input');

  serverSeedInput.addEventListener('input', handleServerSeedChange);
  nonceInput.addEventListener('input', handleNonceChange);
  clientSeedInput.addEventListener('input', handleClientSeedChange);
  riskInput.addEventListener('change', handleRiskChange);


  renderResults();
}

document.addEventListener('DOMContentLoaded', initApp);
